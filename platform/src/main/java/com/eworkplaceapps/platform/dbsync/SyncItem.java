//===============================================================================
// Â© 2015 eWorkplace Apps.  ALL rights reserved.
// Main Author: Shrey Sharma
// Original DATE: 4/25/2015
//===============================================================================
package com.eworkplaceapps.platform.dbsync;

import android.database.Cursor;
import android.util.Xml;

import com.eworkplaceapps.platform.utils.Utils;

import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.io.StringWriter;
import java.util.Date;
import java.util.List;

/**
 * This is a data class for SyncItem table in the database.
 * <p/>
 * Every SQL statement that updates data in the database is recorded in this
 * table. This table is a log of such updaes and is the foundation of sync operations.
 * An INSERT or UPDATE statement may set values in multiple columns. A separate SyncItem
 * record is generated for each column name and value pair.
 * opType property stores the type of operation. There are three types of SQL operations
 * supported: INSERT, UPDATE and DELETE. In addition, it also stores SQL operation markers
 * (as explained below): BEGIN_TRANS, END_TRANS, BEGIN_OP, END_OP.
 * <p/>
 * There are two group types inherent in SyncItem. (1) Group od SyncItems generated for
 * a SQL INSERT/UPDATE statement as described above; (2) Group of SQL ops in a SQL
 * transaction. Depending on the host system, the grouping information is recorded in
 * one of the two manners:
 * (1) SyncItem records are tagged with SyncOpId for Op grouping, and in
 * SyncTransactionId for Transaction grouping;
 * (2) By inserting Begin-End markers for each grouping: BEGIN_OP/END_OP for Op
 * grouping, and BEGIN_TRANS/END_TRANS for Transaction grouping.
 * <p/>
 * For grouping to work, SyncItem records must be inserted and maintained
 * in correct sequential order. This achieved differently for different hosts.
 * On SQLite, use RowId column (system generated); on MS SQL, use
 * timestamp column (system generated).
 * <p/>
 * The source of SyncItem is recorded in DeviceId field. This is used in filtering out
 * records for a given device.
 */
public class SyncItem {

    /**
     * (Datbase) OpType enums
     */
    public interface SyncOpType {
        String INSERT = "insert";
        String UPDATE = "Update";
        String DELETE = "delete";
        String BEGIN_OP = "beginOp";
        String END_OP = "endOp";
        String BEGIN_TRANS = "beginTrans";
        String END_TRANS = "endTrans";
    }

    // The id of the system on which this SQL op was executed.
    private String deviceId = "";
    //  SQL table and PK data to access/create the row.
    private String tableName = "";
    private String pkName = "";
    private String pkValue = "";

    // opType = INSERT, UPDATE, DELETE, BEGIN_TRANS, END_TRANS, BEGIN_OP, END_OP
    private String opType = SyncOpType.INSERT;

    // SQL column name and value to be set
    private String colName = "";
    private String colValue = "";

    // DATE/Time when this record was created.
    // Due to peculiarities of various host systems, this field's granualarity may be
    // either (1) SyncItem level, or (2) SyncOp level, or (3) SyncTransaction level.
    // Our design will work at all three levels.
    // Note that its precision should be in milliseconds.
    private Date createdTime = new Date();

    // The application may use SQL transaction to commit records.
    // syncTransactionId is an id that collects SQL statements included in
    // an transaction. Ideally this should be generated by the underlying SQL server.
    // However if that is not available, it should be generated by the application.
    // Note that syncTransactionId must be unique in the SyncItem at any given time.
    // Note that the default value in the class is 0, so it should be non-zero
    // in the database.
    private String syncTransactionId = "0";

    public String getSyncTransactionId() {
        return syncTransactionId;
    }

    public void setSyncTransactionId(String syncTransactionId) {
        this.syncTransactionId = syncTransactionId;
    }

    public Date getCreatedTime() {
        return createdTime;
    }

    public void setCreatedTime(Date createdTime) {
        this.createdTime = createdTime;
    }

    public String getColValue() {
        return colValue;
    }

    public void setColValue(String colValue) {
        this.colValue = colValue;
    }

    public String getColName() {
        return colName;
    }

    public void setColName(String colName) {
        this.colName = colName;
    }

    public String getOpType() {
        return opType;
    }

    public void setOpType(String opType) {
        this.opType = opType;
    }

    public String getPkValue() {
        return pkValue;
    }

    public void setPkValue(String pkValue) {
        this.pkValue = pkValue;
    }

    public String getPkName() {
        return pkName;
    }

    public void setPkName(String pkName) {
        this.pkName = pkName;
    }

    public String getTableName() {
        return tableName;
    }

    public void setTableName(String tableName) {
        this.tableName = tableName;
    }

    public String getDeviceId() {
        return deviceId;
    }

    public void setDeviceId(String deviceId) {
        this.deviceId = deviceId;
    }

    /**
     * This method is used to set property value from  database ResultSet.
     *
     * @param resultSet
     */
    public void setPropertiesFromResultSet(Cursor resultSet) {

        // If error, set string to "".
        String s = resultSet.getString(resultSet.getColumnIndex("DeviceId"));
        this.deviceId = (s == null) ? "" : s;

        s = resultSet.getString(resultSet.getColumnIndex("TableName"));
        this.tableName = (s == null) ? "" : s;

        s = resultSet.getString(resultSet.getColumnIndex("PKName"));
        this.pkName = (s == null) ? "" : s;

        s = resultSet.getString(resultSet.getColumnIndex("PKValue"));
        this.pkValue = (s == null) ? "" : s;

        s = resultSet.getString(resultSet.getColumnIndex("OpType"));
        if (s != null) {
            this.opType = s;
        }
        s = resultSet.getString(resultSet.getColumnIndex("ColName"));
        this.colName = (s == null) ? "" : s;

        s = resultSet.getString(resultSet.getColumnIndex("ColValue"));
        this.colValue = (s == null) ? "" : s;

        Date dTime = Utils.dateFromString(resultSet.getString(resultSet.getColumnIndex("CreatedTime")), true, true);

        /* Column has null value and dTime has nil value
            When found nil then assigning the value to a non optional variable give me
            fatal error: unexpectedly found nil while unwrapping an Optional value */
        if (dTime != null) {
            this.createdTime = dTime;
        }
    }

    // -------------------- XML --------------------

    /* XML:
    * <SyncItem>
    *   <DeviceId></DeviceId>
    *   <TableName></TableName>
    *   <PKName></PKName>
    *   <PKValue></PKValue>
    *   <OpType></OpType>
    *   <ColName></ColName>
    *   <ColValue></ColValue>
    *   <CreatedTime></CreatedTime>
    *   <SyncOpId></SyncOpId>
    *   <SyncTransactionId></SyncTransactionId>
    *   <Timestamp></Timestamp>
    * </SyncItem>
    */

    /**
     * creates xml Object for sync item
     *
     * @param syncItem
     * @throws IOException
     */
    public static void toXmlWriter(XmlSerializer xmlSerializer, SyncItem syncItem) throws IOException {
        xmlSerializer.startTag("", "SyncItem");
        xmlSerializer.startTag("", "DeviceId");
        xmlSerializer.text(syncItem.getDeviceId());
        xmlSerializer.endTag("", "DeviceId");
        xmlSerializer.startTag("", "TableName");
        xmlSerializer.text(syncItem.getTableName());
        xmlSerializer.endTag("", "TableName");
        xmlSerializer.startTag("", "PKName");
        xmlSerializer.text(syncItem.getPkName());
        xmlSerializer.endTag("", "PKName");
        xmlSerializer.startTag("", "PKValue");
        xmlSerializer.text(syncItem.getPkValue());
        xmlSerializer.endTag("", "PKValue");
        xmlSerializer.startTag("", "OpType");
        xmlSerializer.text(syncItem.getOpType());
        xmlSerializer.endTag("", "OpType");
        xmlSerializer.startTag("", "ColName");
        xmlSerializer.text(syncItem.getColName());
        xmlSerializer.endTag("", "ColName");
        xmlSerializer.startTag("", "ColValue");
        xmlSerializer.text(syncItem.getColValue());
        xmlSerializer.endTag("", "ColValue");
        xmlSerializer.startTag("", "CreatedTime");
        xmlSerializer.text(syncItem.getCreatedTime().toString());
        xmlSerializer.endTag("", "CreatedTime");
        xmlSerializer.endTag("", "SyncItem");
    }

    /**
     * xml list for sync items
     *
     * @param syncList
     * @throws IOException
     */
    private static String listToXmlWriter(List<SyncItem> syncList) throws IOException {
        XmlSerializer xmlSerializer = Xml.newSerializer();
        StringWriter writer = new StringWriter();
        xmlSerializer.setOutput(writer);
        xmlSerializer.startDocument("UTF-8", true);
        xmlSerializer.startTag("", "SyncItemList");
        for (SyncItem syncItem : syncList) {
            toXmlWriter(xmlSerializer, syncItem);
        }
        xmlSerializer.endTag("", "SyncItemList");
        xmlSerializer.endDocument();
        return writer.toString();
    }

}
